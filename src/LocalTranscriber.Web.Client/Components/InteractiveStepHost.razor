@inject IJSRuntime JS

<div class="interactive-host">
    @switch (StepType)
    {
        case "choice":
            <div class="interactive-choice">
                <h3>@Title</h3>
                @if (!string.IsNullOrWhiteSpace(Instructions))
                {
                    <p class="interactive-instructions">@Instructions</p>
                }
                <div class="choice-buttons">
                    @if (Choices != null)
                    {
                        @foreach (var choice in Choices)
                        {
                            var c = choice;
                            <button class="choice-btn" type="button" @onclick="() => OnChoiceSelected(c)">
                                @c.Label
                            </button>
                        }
                    }
                </div>
            </div>
            break;

        case "multiRecord":
            <div class="interactive-multi-record">
                <h3>@Title</h3>
                @if (!string.IsNullOrWhiteSpace(Instructions))
                {
                    <p class="interactive-instructions">@Instructions</p>
                }

                <div class="multi-record-progress">
                    <span>@_completedCount / @(Prompts?.Count ?? 0) answered</span>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: @(ProgressPercent)%"></div>
                    </div>
                </div>

                <div class="prompt-cards">
                    @if (Prompts != null)
                    {
                        @for (var i = 0; i < Prompts.Count; i++)
                        {
                            var idx = i;
                            var prompt = Prompts[i];
                            var mode = GetInputMode(idx);
                            var hasRecording = _recordings.ContainsKey(idx);
                            var hasTypedText = _typedTexts.TryGetValue(idx, out var typed) && !string.IsNullOrWhiteSpace(typed);
                            var isCompleted = (mode == InputMode.Type && hasTypedText) || ((mode == InputMode.Record || mode == InputMode.Upload) && hasRecording);
                            <div class="prompt-card @(isCompleted ? "completed" : "") @(_activeRecordingIndex == idx ? "recording" : "")">
                                <div class="prompt-header">
                                    <span class="prompt-number">@(idx + 1)</span>
                                    <span class="prompt-text">@prompt</span>
                                    <button class="tts-btn @(GetTtsStateClass(idx))" type="button"
                                            title="Read aloud" @onclick="() => ToggleTtsAsync(idx, prompt)">
                                        @if (GetTtsState(idx) == TtsState.Loading)
                                        {
                                            <svg class="tts-icon tts-spinner" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                                            </svg>
                                        }
                                        else if (GetTtsState(idx) == TtsState.Playing)
                                        {
                                            <svg class="tts-icon" viewBox="0 0 24 24" fill="currentColor">
                                                <rect x="6" y="5" width="4" height="14" rx="1"/>
                                                <rect x="14" y="5" width="4" height="14" rx="1"/>
                                            </svg>
                                        }
                                        else
                                        {
                                            <svg class="tts-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07" stroke-linecap="round"/>
                                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14" stroke-linecap="round"/>
                                            </svg>
                                        }
                                    </button>
                                </div>
                                <div class="prompt-actions">
                                    <div class="input-mode-switcher">
                                        <button class="mode-btn @(mode == InputMode.Record ? "active" : "")" type="button"
                                                @onclick="() => SetInputMode(idx, InputMode.Record)">Record</button>
                                        <button class="mode-btn @(mode == InputMode.Type ? "active" : "")" type="button"
                                                @onclick="() => SetInputMode(idx, InputMode.Type)">Type</button>
                                        <button class="mode-btn @(mode == InputMode.Upload ? "active" : "")" type="button"
                                                @onclick="() => SetInputMode(idx, InputMode.Upload)">Upload</button>
                                    </div>

                                    @switch (mode)
                                    {
                                        case InputMode.Record:
                                            @if (_activeRecordingIndex == idx)
                                            {
                                                <button class="record-action stop" type="button" @onclick="() => StopRecordingAsync(idx)">
                                                    Stop
                                                </button>
                                            }
                                            else
                                            {
                                                <button class="record-action @(hasRecording ? "re-record" : "record")" type="button" @onclick="() => StartRecordingAsync(idx)">
                                                    @(hasRecording ? "Re-record" : "Record")
                                                </button>
                                            }
                                            break;

                                        case InputMode.Upload:
                                            <label class="prompt-upload-input">
                                                <span>@(hasRecording ? "Replace file" : "Choose audio file")</span>
                                                <InputFile accept="audio/*,.wav,.mp3,.m4a,.webm" OnChange="@(e => HandlePromptUploadAsync(idx, e))" />
                                            </label>
                                            break;
                                    }
                                </div>

                                @if (mode == InputMode.Type)
                                {
                                    <textarea class="prompt-type-input" placeholder="Type your answer..."
                                              value="@(GetTypedText(idx))"
                                              @oninput="@(e => HandleTypedInput(idx, e))"></textarea>
                                }

                                @if ((mode == InputMode.Record || mode == InputMode.Upload) && hasRecording && _recordings[idx].Transcription != null)
                                {
                                    <div class="prompt-transcription">
                                        <p>@_recordings[idx].Transcription</p>
                                    </div>
                                }
                            </div>
                        }
                    }
                </div>

                @if (OrphanedRecordings is { Count: > 0 })
                {
                    <div class="orphan-section">
                        <h4>Previous answers (questions changed)</h4>
                        @foreach (var orphan in OrphanedRecordings)
                        {
                            var key = orphan.Key;
                            @if (!_deletedOrphanKeys.Contains(key))
                            {
                                <div class="orphan-item">
                                    <div class="orphan-header">
                                        <span class="orphan-tag">Orphaned</span>
                                        <span class="orphan-question">@orphan.Value.Question</span>
                                        <button class="orphan-delete-btn" type="button" @onclick="() => DeleteOrphan(key)">Delete</button>
                                    </div>
                                    <p class="orphan-answer">@orphan.Value.Answer</p>
                                </div>
                            }
                        }
                    </div>
                }

                @if (_completedCount == (Prompts?.Count ?? 0) && _completedCount > 0)
                {
                    <button class="submit-all-btn" type="button" @onclick="SubmitAllRecordings">
                        Submit All Answers
                    </button>
                }
            </div>
            break;

        case "userReview":
            <div class="interactive-review">
                <h3>@(Title ?? "Review & Edit")</h3>
                @if (!string.IsNullOrWhiteSpace(Instructions))
                {
                    <p class="interactive-instructions">@Instructions</p>
                }
                <textarea class="review-editor" @bind="_reviewText" @bind:event="oninput"></textarea>
                <div class="review-actions">
                    <button class="choice-btn primary" type="button" @onclick="ApproveReview">Approve</button>
                    @if (ShowPlayback)
                    {
                        <span class="review-note">Use playback controls above to verify accuracy</span>
                    }
                </div>
            </div>
            break;

        default:
            <div class="interactive-unknown">
                <p>Unknown interactive step type: @StepType</p>
            </div>
            break;
    }
</div>

@code {
    [Parameter] public string StepType { get; set; } = "";
    [Parameter] public string? Title { get; set; }
    [Parameter] public string? Instructions { get; set; }
    [Parameter] public List<ChoiceOption>? Choices { get; set; }
    [Parameter] public List<string>? Prompts { get; set; }
    [Parameter] public string? InputText { get; set; }
    [Parameter] public bool ShowPlayback { get; set; }
    [Parameter] public string? InteractionId { get; set; }
    [Parameter] public Dictionary<string, PreviousRecordingEntry>? PreviousRecordings { get; set; }
    [Parameter] public Dictionary<string, OrphanedRecordingEntry>? OrphanedRecordings { get; set; }
    [Parameter] public EventCallback<ChoiceResult> OnChoiceCompleted { get; set; }
    [Parameter] public EventCallback<MultiRecordResult> OnMultiRecordCompleted { get; set; }
    [Parameter] public EventCallback<ReviewResult> OnReviewCompleted { get; set; }

    private enum InputMode { Record, Type, Upload }
    private enum TtsState { Idle, Loading, Playing }

    private Dictionary<int, RecordingEntry> _recordings = new();
    private Dictionary<int, InputMode> _inputModes = new();
    private Dictionary<int, string> _typedTexts = new();
    private Dictionary<int, TtsState> _ttsStates = new();
    private HashSet<string> _deletedOrphanKeys = new();
    private int _activeRecordingIndex = -1;
    private string _reviewText = "";
    private string? _lastInteractionId;

    private int _completedCount
    {
        get
        {
            if (Prompts == null) return 0;
            var count = 0;
            for (var i = 0; i < Prompts.Count; i++)
            {
                var mode = GetInputMode(i);
                if (mode == InputMode.Type && _typedTexts.TryGetValue(i, out var text) && !string.IsNullOrWhiteSpace(text))
                    count++;
                else if ((mode == InputMode.Record || mode == InputMode.Upload) && _recordings.ContainsKey(i))
                    count++;
            }
            return count;
        }
    }

    private double ProgressPercent => Prompts?.Count > 0 ? (double)_completedCount / Prompts.Count * 100 : 0;

    protected override void OnParametersSet()
    {
        if (StepType == "userReview" && !string.IsNullOrEmpty(InputText) && string.IsNullOrEmpty(_reviewText))
        {
            _reviewText = InputText;
        }

        // Pre-populate recordings from previous answers when interaction changes
        if (StepType == "multiRecord" && InteractionId != _lastInteractionId)
        {
            _lastInteractionId = InteractionId;
            _recordings.Clear();
            _inputModes.Clear();
            _typedTexts.Clear();
            _deletedOrphanKeys.Clear();

            if (PreviousRecordings != null && Prompts != null)
            {
                foreach (var kvp in PreviousRecordings)
                {
                    if (int.TryParse(kvp.Key, out var index) && index >= 0 && index < Prompts.Count)
                    {
                        _recordings[index] = new RecordingEntry("", "", kvp.Value.Answer);
                    }
                }
            }
        }
    }

    private void DeleteOrphan(string key)
    {
        _deletedOrphanKeys.Add(key);
    }

    private async Task OnChoiceSelected(ChoiceOption choice)
    {
        await OnChoiceCompleted.InvokeAsync(new ChoiceResult(choice.Label, choice.Target));
    }

    private async Task StartRecordingAsync(int index)
    {
        if (_activeRecordingIndex >= 0)
            return;

        _activeRecordingIndex = index;
        try
        {
            await JS.InvokeVoidAsync("localTranscriberRecorder.startRecording", null);
        }
        catch
        {
            _activeRecordingIndex = -1;
        }
    }

    private async Task StopRecordingAsync(int index)
    {
        if (_activeRecordingIndex != index)
            return;

        try
        {
            var payload = await JS.InvokeAsync<RecordingPayload?>("localTranscriberRecorder.stopRecording");
            if (payload != null)
            {
                _recordings[index] = new RecordingEntry(payload.Base64, payload.MimeType, null);

                // Transcribe the recording inline
                try
                {
                    var result = await JS.InvokeAsync<TranscriptionResult?>(
                        "localTranscriberBrowser.transcribeAudioBase64",
                        payload.Base64, payload.MimeType);
                    if (result != null)
                    {
                        _recordings[index] = _recordings[index] with { Transcription = result.Text };
                    }
                }
                catch
                {
                    // Transcription is optional - recording still captured
                }
            }
        }
        finally
        {
            _activeRecordingIndex = -1;
            await InvokeAsync(StateHasChanged);
        }
    }

    private InputMode GetInputMode(int index) =>
        _inputModes.TryGetValue(index, out var mode) ? mode : InputMode.Record;

    private void SetInputMode(int index, InputMode mode)
    {
        _inputModes[index] = mode;
    }

    private string GetTypedText(int index) =>
        _typedTexts.TryGetValue(index, out var text) ? text : "";

    private void SetTypedText(int index, string text)
    {
        _typedTexts[index] = text;
    }

    private void HandleTypedInput(int index, ChangeEventArgs e)
    {
        _typedTexts[index] = e.Value?.ToString() ?? "";
    }

    private async Task HandlePromptUploadAsync(int index, InputFileChangeEventArgs args)
    {
        var file = args.File;
        if (file == null) return;

        try
        {
            const long maxSize = 50 * 1024 * 1024; // 50 MB
            using var stream = file.OpenReadStream(maxSize);
            using var ms = new System.IO.MemoryStream();
            await stream.CopyToAsync(ms);
            var base64 = Convert.ToBase64String(ms.ToArray());
            var mimeType = file.ContentType;

            _recordings[index] = new RecordingEntry(base64, mimeType, null);

            try
            {
                var result = await JS.InvokeAsync<TranscriptionResult?>(
                    "localTranscriberBrowser.transcribeAudioBase64",
                    base64, mimeType);
                if (result != null)
                {
                    _recordings[index] = _recordings[index] with { Transcription = result.Text };
                }
            }
            catch
            {
                // Transcription is optional - upload still captured
            }
        }
        catch
        {
            // File read failed
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task SubmitAllRecordings()
    {
        if (Prompts == null) return;

        var pairs = new List<QAPair>();
        for (var i = 0; i < Prompts.Count; i++)
        {
            var mode = GetInputMode(i);
            string answer;
            if (mode == InputMode.Type)
            {
                answer = _typedTexts.TryGetValue(i, out var text) ? text ?? "" : "";
            }
            else
            {
                answer = _recordings.ContainsKey(i) ? _recordings[i].Transcription ?? "" : "";
            }
            pairs.Add(new QAPair(Prompts[i], answer));
        }

        await OnMultiRecordCompleted.InvokeAsync(new MultiRecordResult(pairs, _deletedOrphanKeys.ToList()));
    }

    private async Task ApproveReview()
    {
        await OnReviewCompleted.InvokeAsync(new ReviewResult(_reviewText, true));
    }

    // TTS playback
    private TtsState GetTtsState(int index) =>
        _ttsStates.TryGetValue(index, out var state) ? state : TtsState.Idle;

    private string GetTtsStateClass(int index) => GetTtsState(index) switch
    {
        TtsState.Loading => "loading",
        TtsState.Playing => "playing",
        _ => ""
    };

    private async Task ToggleTtsAsync(int index, string text)
    {
        var current = GetTtsState(index);

        if (current == TtsState.Playing)
        {
            await JS.InvokeVoidAsync("localTranscriberTts.stopSpeaking");
            _ttsStates[index] = TtsState.Idle;
            return;
        }

        // Stop any other playing prompt
        foreach (var key in _ttsStates.Keys.ToList())
        {
            if (_ttsStates[key] == TtsState.Playing)
                _ttsStates[key] = TtsState.Idle;
        }

        _ttsStates[index] = TtsState.Loading;
        StateHasChanged();

        try
        {
            await JS.InvokeVoidAsync("localTranscriberTts.speak", text);
            _ttsStates[index] = TtsState.Playing;
            StateHasChanged();

            // Poll until speaking finishes
            while (await JS.InvokeAsync<bool>("localTranscriberTts.isSpeaking"))
            {
                await Task.Delay(500);
            }

            _ttsStates[index] = TtsState.Idle;
        }
        catch
        {
            _ttsStates[index] = TtsState.Idle;
        }

        StateHasChanged();
    }

    // Models
    public record ChoiceOption(string Label, string? Target);
    public record ChoiceResult(string SelectedLabel, string? SelectedTarget);
    public record MultiRecordResult(List<QAPair> Pairs, List<string>? DeletedOrphanKeys = null);
    public record QAPair(string Question, string Answer);
    public record ReviewResult(string Text, bool Approved);
    public record PreviousRecordingEntry(string Question, string Answer);
    public record OrphanedRecordingEntry(string Question, string Answer);
    private record RecordingEntry(string Base64, string MimeType, string? Transcription);
    private record RecordingPayload(string Base64, string MimeType, string FileName);
    private record TranscriptionResult(string Text);
}
