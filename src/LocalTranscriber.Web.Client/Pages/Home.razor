@page "/"
@using System.Globalization
@implements IAsyncDisposable
@inject IJSRuntime JS

<PageTitle>LocalTranscriber - Browser Transcription</PageTitle>

<div class="screen-root minimal">
    <div class="top-left-brand" tabindex="-1">
        <p class="eyebrow" tabindex="-1">LocalTranscriber</p>
        <h1 tabindex="-1">Browser Transcription</h1>
        <p class="subtext" tabindex="-1">100% client-side ‚Ä¢ No data leaves your browser</p>
    </div>

    @if (_minimalStage == MinimalStage.Processing)
    {
        <section class="minimal-processing">
            <div class="orbit-loader"></div>
            <h2>@_statusMessage</h2>
            <p class="subtext">Processing audio locally in your browser.</p>

            <div class="log-stream">
                @if (_timeline.Count == 0)
                {
                    <div class="log-line">Waiting for first log event...</div>
                }
                else
                {
                    var logs = GetLatestLogs(9);
                    @for (var i = 0; i < logs.Count; i++)
                    {
                        var item = logs[i];
                        var opacity = 1 - (i * 0.12);
                        <div class="log-line @(item.IsError ? "error" : item.IsCompleted ? "complete" : "")" style="opacity:@opacity">
                            <span>@item.Percent%</span>
                            <span>@item.Message</span>
                        </div>
                    }
                }
            </div>

            @if (!string.IsNullOrWhiteSpace(_errorMessage))
            {
                <div class="error-box">@_errorMessage</div>
                <button class="ghost-btn" type="button" @onclick="BackToCapture">Back</button>
            }
        </section>
    }
    else if (_minimalStage == MinimalStage.Results)
    {
        <section class="minimal-results">
            <div class="panel-head">
                <h2>Transcription Result</h2>
                <button class="ghost-btn" type="button" @onclick="ResetWorkflowAsync">New Transcription</button>
            </div>

            @if (!string.IsNullOrWhiteSpace(_errorMessage))
            {
                <div class="error-box">@_errorMessage</div>
            }

            <div class="tab-row">
                <button class="@GetTabClass(ResultTab.Final)" type="button" @onclick="() => SetResultTab(ResultTab.Final)">Processed</button>
                <button class="@GetTabClass(ResultTab.Raw)" type="button" @onclick="() => SetResultTab(ResultTab.Raw)">Raw</button>
                <button class="@GetTabClass(ResultTab.Logs)" type="button" @onclick="() => SetResultTab(ResultTab.Logs)">Logs</button>
                
                <span class="toolbar-spacer"></span>
                
                <button class="chip-btn" type="button" @onclick="CopyToClipboardAsync">Copy to Clipboard</button>
                <button class="chip-btn" type="button" @onclick="ExportMarkdownAsync">Export Markdown</button>
            </div>

            <div class="result-edit-toolbar" style="display:none">
                <button class="chip-btn" type="button" @onclick="CopyToClipboardAsync">Copy to Clipboard</button>
                <button class="chip-btn" type="button" @onclick="ExportMarkdownAsync">Export Markdown</button>
            </div>

            <div class="tab-panel">
                @switch (_activeTab)
                {
                    case ResultTab.Raw:
                        <pre class="text-pane">@(_rawWhisperText ?? "(empty)")</pre>
                        break;

                    case ResultTab.Logs:
                        <div class="log-scroll">
                            @foreach (var item in _timeline)
                            {
                                <div class="timeline-item @(item.IsError ? "error" : item.IsCompleted ? "complete" : "")">
                                    <span>@item.Percent%</span>
                                    <span>@item.Message</span>
                                </div>
                            }
                        </div>
                        break;

                    default:
                        <pre class="text-pane">@(_markdownOutput ?? "(empty)")</pre>
                        break;
                }
            </div>
        </section>
    }
    else
    {
        <section class="minimal-capture">
            @if (!_browserCapabilities.Supported)
            {
                <div class="error-box">
                    <strong>Browser Not Supported</strong>
                    <p>@_browserCapabilities.Reason</p>
                    <p>Please use a modern browser with WebGPU support (Chrome 113+, Edge 113+).</p>
                </div>
            }
            else
            {
                @if (!string.IsNullOrWhiteSpace(_errorMessage))
                {
                    <div class="error-box">@_errorMessage</div>
                }

                <div class="capture-hub">
                    @if (_hasAudio && !_isRecording)
                    {
                        <button class="send-launch" type="button" title="Transcribe" @onclick="SubmitAsync" disabled="@_isSubmitting">
                            <span class="rocket launch-icon" aria-hidden="true">
                                <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M3 11.5 21 3l-8.5 18-1.9-7.6z" />
                                    <path d="m12.6 13.4-3.7 3.7" />
                                </svg>
                            </span>
                            <span>Transcribe</span>
                        </button>
                    }

                    <div class="record-stack">
                        <button @ref="_recordButtonRef" class="record-button @GetRecordClass()" type="button" @onclick="ToggleRecordAsync" disabled="@(_isSubmitting || _devices.Count == 0)">
                            <span class="record-core"></span>
                            <span class="record-label">@(_isRecording ? "Stop" : "Record")</span>
                        </button>

                        <label class="upload-fab @(_uploadedAudio is not null ? "active" : "")" title="Upload audio file" aria-label="Upload audio file">
                            <span class="upload-icon" aria-hidden="true">
                                <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 15V5" />
                                    <path d="m8.5 8.5 3.5-3.5 3.5 3.5" />
                                    <path d="M4 15.5v2a2.5 2.5 0 0 0 2.5 2.5h11a2.5 2.5 0 0 0 2.5-2.5v-2" />
                                </svg>
                            </span>
                            <span class="upload-text">Upload</span>
                            <InputFile class="upload-input" OnChange="HandleUploadAsync" accept="audio/*,.wav,.mp3,.m4a,.webm" disabled="@(_isRecording || _isSubmitting)" />
                        </label>
                    </div>

                    @if (_browserCapabilities.IsMobile)
                    {
                        <div class="mobile-notice">
                            <strong>üì± Mobile Mode</strong>
                            <span>Using @_model model for best performance. Larger models may crash on mobile browsers.</span>
                        </div>
                    }

                    <details class="settings-panel">
                        <summary class="settings-panel-toggle">
                            <svg class="icon-svg" viewBox="0 0 24 24"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
                            <span>Settings</span>
                        </summary>
                        <div class="settings-panel-content">
                            <label class="mic-select-wrap">
                                <span>Microphone</span>
                                <select @bind="_selectedDeviceId" disabled="@(_devices.Count == 0 || _isRecording || _isSubmitting)">
                                    @if (_devices.Count == 0)
                                    {
                                        <option value="">No microphone devices detected</option>
                                    }
                                    else
                                    {
                                        @foreach (var device in _devices)
                                        {
                                            <option value="@device.DeviceId">@device.Label</option>
                                        }
                                    }
                                </select>
                            </label>

                            <div class="settings-row">
                                <label>
                                    <span>Model</span>
                                    <select @bind="_model" disabled="@_isSubmitting">
                                        @foreach (var model in _models)
                                        {
                                            <option value="@model">@model</option>
                                        }
                                    </select>
                                </label>

                                <label>
                                    <span>WebLLM Model</span>
                                    <select @bind="_webLlmModel" disabled="@_isSubmitting">
                                        @foreach (var model in _webLlmModelPresets)
                                        {
                                            <option value="@model">@model</option>
                                        }
                                    </select>
                                </label>

                                <label class="toggle-label">
                                    <span>Detect Speakers</span>
                                    <div class="toggle-switch">
                                        <input type="checkbox" @bind="_enableSpeakerLabels" disabled="@_isSubmitting" />
                                        <span class="toggle-slider"></span>
                                    </div>
                                </label>

                                <label>
                                    <span>Model Mirror @(_mirrorStatus)</span>
                                    <select @bind="_selectedMirror" @bind:after="OnMirrorChangedAsync" disabled="@_isSubmitting">
                                        @foreach (var mirror in _mirrors)
                                        {
                                            <option value="@mirror.Url">@mirror.Name (@mirror.Region)</option>
                                        }
                                    </select>
                                </label>
                            </div>

                    @* Advanced Settings Section *@
                    <details class="settings-accordion">
                        <summary class="settings-accordion-toggle">
                            <span>‚öôÔ∏è Advanced Settings</span>
                        </summary>
                        <div class="settings-accordion-content">
                            <div class="settings-grid">
                                <label>
                                    <span>Strict Transcript</span>
                                    <select @bind="_tuningStrictTranscript">
                                        <option value="true">Preserve wording strictly</option>
                                        <option value="false">Allow light smoothing</option>
                                    </select>
                                </label>
                                
                                <label>
                                    <span>Include Action Items</span>
                                    <select @bind="_tuningIncludeActionItems">
                                        <option value="true">Yes - extract action items</option>
                                        <option value="false">No - minimal actions</option>
                                    </select>
                                </label>
                                
                                <label>
                                    <span>Summary Min Bullets</span>
                                    <input type="number" @bind="_tuningSummaryMin" min="1" max="12" />
                                </label>
                                
                                <label>
                                    <span>Summary Max Bullets</span>
                                    <input type="number" @bind="_tuningSummaryMax" min="1" max="20" />
                                </label>
                                
                                <label>
                                    <span>Temperature</span>
                                    <input type="range" @bind="_tuningTemperature" min="0" max="1.0" step="0.05" />
                                    <span class="range-value">@_tuningTemperature.ToString("F2")</span>
                                </label>
                                
                                <label>
                                    <span>Sensitivity</span>
                                    <input type="range" @bind="_tuningSensitivity" min="0" max="100" step="5" />
                                    <span class="range-value">@_tuningSensitivity%</span>
                                </label>
                            </div>
                            <div class="settings-actions">
                                <button class="chip-btn" type="button" @onclick="SaveTuningAsync">Save Settings</button>
                                <button class="chip-btn ghost" type="button" @onclick="ResetTuningAsync">Reset to Defaults</button>
                            </div>
                        </div>
                    </details>

                    @* Prompt Editor Section *@
                    <details class="settings-accordion">
                        <summary class="settings-accordion-toggle">
                            <span>‚úèÔ∏è Edit Prompts</span>
                        </summary>
                        <div class="prompt-editor-layout">
                            <div class="prompt-editor-content">
                                <div class="prompt-field">
                                    <label>
                                        <span>System Message</span>
                                        <textarea @bind="_promptSystemMessage" rows="2" placeholder="You are a transcription editor."></textarea>
                                    </label>
                                </div>
                                <div class="prompt-field">
                                    <label>
                                        <span>Cleanup Prompt</span>
                                        <textarea @bind="_promptCleanup" rows="8" placeholder="Rules for formatting..."></textarea>
                                    </label>
                                </div>
                                <div class="prompt-field">
                                    <label>
                                        <span>Output Template</span>
                                        <textarea @bind="_promptOutputTemplate" rows="8" placeholder="# Transcription..."></textarea>
                                    </label>
                                </div>
                                <div class="prompt-actions">
                                    <button class="chip-btn" type="button" @onclick="SavePromptsAsync">Save Prompts</button>
                                    <button class="chip-btn ghost" type="button" @onclick="ResetPromptsAsync">Reset to Defaults</button>
                                </div>
                            </div>
                            <aside class="prompt-placeholders">
                                <strong>Available Placeholders</strong>
                                <dl>
                                    <dt><code>{strictness}</code></dt>
                                    <dd>Wording strictness rule (based on settings)</dd>
                                    
                                    <dt><code>{actionItemRule}</code></dt>
                                    <dd>Action items inclusion rule</dd>
                                    
                                    <dt><code>{summaryMinBullets}</code></dt>
                                    <dd>Minimum summary bullet points</dd>
                                    
                                    <dt><code>{summaryMaxBullets}</code></dt>
                                    <dd>Maximum summary bullet points</dd>
                                    
                                    <dt><code>{model}</code></dt>
                                    <dd>Whisper model used (e.g., "small.en")</dd>
                                    
                                    <dt><code>{language}</code></dt>
                                    <dd>Detected/specified language</dd>
                                </dl>
                            </aside>
                        </div>
                    </details>
                        </div>
                    </details>

                    @if (!string.IsNullOrWhiteSpace(_sourceDescription))
                    {
                        <p class="subtext">@_sourceDescription</p>
                    }
                </div>
            }
        </section>
    }
</div>

@code {
    private static readonly string[] _models = ["Tiny", "TinyEn", "Base", "BaseEn", "Small", "SmallEn"];
    private static readonly string[] _defaultWebLlmModels =
    [
        "Llama-3.1-8B-Instruct-q4f16_1-MLC",
        "Qwen2.5-7B-Instruct-q4f16_1-MLC",
        "Phi-3.5-mini-instruct-q4f16_1-MLC"
    ];

    private ElementReference _recordButtonRef;
    private DotNetObjectReference<Home>? _dotNetRef;
    private readonly List<ProgressItem> _timeline = [];
    private readonly List<AudioDevice> _devices = [];
    private readonly List<string> _webLlmModelPresets = [];
    private BrowserAudioPayload? _browserRecording;
    private UploadedAudioPayload? _uploadedAudio;

    private string? _selectedDeviceId;
    private string _model = "SmallEn";
    private string _webLlmModel = "Llama-3.1-8B-Instruct-q4f16_1-MLC";
    private bool _enableSpeakerLabels = true;
    
    // Mirror configuration
    private readonly List<MirrorInfo> _mirrors = [];
    private string _selectedMirror = "https://huggingface.co";
    private string _mirrorStatus = "";

    // Prompt templates
    private string _promptSystemMessage = "";
    private string _promptCleanup = "";
    private string _promptOutputTemplate = "";

    // Tuning options
    private string _tuningStrictTranscript = "true";
    private string _tuningIncludeActionItems = "true";
    private int _tuningSummaryMin = 3;
    private int _tuningSummaryMax = 8;
    private double _tuningTemperature = 0.2;
    private int _tuningSensitivity = 50;

    private BrowserExecutionCapabilities _browserCapabilities = new(false, false, false, false, false, 0, null, "Checking...");

    private bool _isRecording;
    private bool _isSubmitting;
    private string? _activeJobId;
    private string _statusMessage = "Ready";
    private string? _markdownOutput;
    private string? _rawWhisperText;
    private string? _errorMessage;

    private MinimalStage _minimalStage = MinimalStage.Capture;
    private ResultTab _activeTab = ResultTab.Final;

    private bool _hasAudio => _browserRecording is not null || _uploadedAudio is not null;

    private string? _sourceDescription
    {
        get
        {
            if (_browserRecording is not null)
                return $"Recorded: {_browserRecording.FileName} ({FormatBytes(_browserRecording.Size)})";
            if (_uploadedAudio is not null)
                return $"Uploaded: {_uploadedAudio.FileName} ({FormatBytes(_uploadedAudio.Bytes.Length)})";
            return null;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await RefreshBrowserCapabilitiesAsync();
            await RefreshDevicesAsync();
            await RefreshWebLlmModelsAsync();
            await RefreshMirrorsAsync();
            await LoadPromptsAsync();
            await LoadTuningAsync();
            StateHasChanged();
            
            // Focus record button after initial render
            try
            {
                await _recordButtonRef.FocusAsync();
            }
            catch { }
        }
    }

    private async Task RefreshBrowserCapabilitiesAsync()
    {
        try
        {
            _browserCapabilities = await JS.InvokeAsync<BrowserExecutionCapabilities>("localTranscriberBrowser.getCapabilities");
            
            // Auto-select recommended model on mobile
            if (_browserCapabilities.IsMobile && _browserCapabilities.RecommendedModels?.Length > 0)
            {
                var recommended = _browserCapabilities.RecommendedModels[0];
                if (_models.Contains(recommended))
                {
                    _model = recommended;
                }
            }
        }
        catch (Exception ex)
        {
            _browserCapabilities = new(false, false, false, false, false, 0, null, $"Error: {ex.Message}");
        }
    }

    private async Task RefreshDevicesAsync()
    {
        try
        {
            var devices = await JS.InvokeAsync<AudioDevice[]>("localTranscriberRecorder.listInputDevices");
            _devices.Clear();
            _devices.AddRange(devices);
            if (_devices.Count > 0 && string.IsNullOrWhiteSpace(_selectedDeviceId))
                _selectedDeviceId = _devices[0].DeviceId;
        }
        catch { }
    }

    private async Task RefreshWebLlmModelsAsync()
    {
        _webLlmModelPresets.Clear();
        try
        {
            var available = await JS.InvokeAsync<string[]>("localTranscriberBrowser.listWebLlmModels");
            if (available?.Length > 0)
            {
                var filtered = available.Where(m => m.Contains("7B") || m.Contains("8B") || m.Contains("mini")).Take(6);
                _webLlmModelPresets.AddRange(filtered);
            }
        }
        catch { }

        if (_webLlmModelPresets.Count == 0)
            _webLlmModelPresets.AddRange(_defaultWebLlmModels);
    }

    private async Task RefreshMirrorsAsync()
    {
        _mirrors.Clear();
        try
        {
            var mirrors = await JS.InvokeAsync<MirrorInfo[]>("localTranscriberBrowser.listMirrors");
            if (mirrors?.Length > 0)
                _mirrors.AddRange(mirrors);
            
            // Get current preference
            var pref = await JS.InvokeAsync<string?>("localTranscriberBrowser.getMirrorPreference");
            if (!string.IsNullOrEmpty(pref))
                _selectedMirror = pref;
            else if (_mirrors.Count > 0)
                _selectedMirror = _mirrors[0].Url;
        }
        catch { }
        
        // Default fallback
        if (_mirrors.Count == 0)
        {
            _mirrors.Add(new MirrorInfo("https://huggingface.co", "HuggingFace", "Global"));
            _mirrors.Add(new MirrorInfo("https://hf-mirror.com", "HF-Mirror", "China-friendly"));
        }
    }

    private async Task OnMirrorChangedAsync()
    {
        if (string.IsNullOrEmpty(_selectedMirror)) return;
        
        try
        {
            _mirrorStatus = "(setting...)";
            StateHasChanged();
            
            await JS.InvokeAsync<string?>("localTranscriberBrowser.setMirrorPreference", _selectedMirror);
            _mirrorStatus = "‚úì";
        }
        catch
        {
            _mirrorStatus = "‚úó";
        }
        
        // Clear status after a moment
        _ = Task.Delay(2000).ContinueWith(_ =>
        {
            _mirrorStatus = "";
            InvokeAsync(StateHasChanged);
        });
    }

    private async Task LoadPromptsAsync()
    {
        try
        {
            var templates = await JS.InvokeAsync<PromptTemplatesJs>("localTranscriberBrowser.getPromptTemplates");
            if (templates != null)
            {
                _promptSystemMessage = templates.SystemMessage ?? "";
                _promptCleanup = templates.CleanupPrompt ?? "";
                _promptOutputTemplate = templates.OutputTemplate ?? "";
            }
        }
        catch { }
    }

    private async Task SavePromptsAsync()
    {
        try
        {
            var templates = new PromptTemplatesJs(_promptSystemMessage, _promptCleanup, _promptOutputTemplate);
            await JS.InvokeVoidAsync("localTranscriberBrowser.setPromptTemplates", templates);
        }
        catch { }
    }

    private async Task ResetPromptsAsync()
    {
        try
        {
            var defaults = await JS.InvokeAsync<PromptTemplatesJs>("localTranscriberBrowser.resetPromptTemplates");
            if (defaults != null)
            {
                _promptSystemMessage = defaults.SystemMessage ?? "";
                _promptCleanup = defaults.CleanupPrompt ?? "";
                _promptOutputTemplate = defaults.OutputTemplate ?? "";
            }
        }
        catch { }
    }

    private async Task LoadTuningAsync()
    {
        try
        {
            var tuning = await JS.InvokeAsync<TuningOptionsJs>("localTranscriberBrowser.getTuningOptions");
            if (tuning != null)
            {
                _tuningStrictTranscript = tuning.StrictTranscript ? "true" : "false";
                _tuningIncludeActionItems = tuning.IncludeActionItems ? "true" : "false";
                _tuningSummaryMin = tuning.SummaryMinBullets;
                _tuningSummaryMax = tuning.SummaryMaxBullets;
                _tuningTemperature = tuning.Temperature;
                _tuningSensitivity = tuning.Sensitivity;
            }
        }
        catch { }
    }

    private async Task SaveTuningAsync()
    {
        try
        {
            var tuning = new TuningOptionsJs(
                _tuningStrictTranscript == "true",
                _tuningIncludeActionItems == "true",
                _tuningSummaryMin,
                _tuningSummaryMax,
                _tuningTemperature,
                _tuningSensitivity
            );
            await JS.InvokeVoidAsync("localTranscriberBrowser.setTuningOptions", tuning);
        }
        catch { }
    }

    private async Task ResetTuningAsync()
    {
        try
        {
            var defaults = await JS.InvokeAsync<TuningOptionsJs>("localTranscriberBrowser.resetTuningOptions");
            if (defaults != null)
            {
                _tuningStrictTranscript = defaults.StrictTranscript ? "true" : "false";
                _tuningIncludeActionItems = defaults.IncludeActionItems ? "true" : "false";
                _tuningSummaryMin = defaults.SummaryMinBullets;
                _tuningSummaryMax = defaults.SummaryMaxBullets;
                _tuningTemperature = defaults.Temperature;
                _tuningSensitivity = defaults.Sensitivity;
            }
        }
        catch { }
    }

    private async Task ToggleRecordAsync()
    {
        if (_isRecording)
        {
            await StopRecordingAsync();
        }
        else
        {
            await StartRecordingAsync();
        }
    }

    private async Task StartRecordingAsync()
    {
        _errorMessage = null;
        try
        {
            await JS.InvokeVoidAsync("localTranscriberRecorder.startRecording", _selectedDeviceId);
            _isRecording = true;
            _uploadedAudio = null;
        }
        catch (Exception ex)
        {
            _errorMessage = $"Recording failed: {ex.Message}";
        }
    }

    private async Task StopRecordingAsync()
    {
        try
        {
            var payload = await JS.InvokeAsync<BrowserAudioPayload?>("localTranscriberRecorder.stopRecording");
            if (payload is not null)
            {
                _browserRecording = payload;
                _uploadedAudio = null;
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Stop failed: {ex.Message}";
        }
        finally
        {
            _isRecording = false;
        }
    }

    private async Task HandleUploadAsync(InputFileChangeEventArgs args)
    {
        _errorMessage = null;
        try
        {
            var file = args.File;
            if (file is null) return;

            await using var stream = file.OpenReadStream(250 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);

            _uploadedAudio = new UploadedAudioPayload(file.Name, file.ContentType ?? "audio/wav", ms.ToArray());
            _browserRecording = null;
        }
        catch (Exception ex)
        {
            _errorMessage = $"Upload failed: {ex.Message}";
        }
    }

    private async Task SubmitAsync()
    {
        if (!_hasAudio || _isSubmitting) return;

        _isSubmitting = true;
        _errorMessage = null;
        _timeline.Clear();
        _markdownOutput = null;
        _rawWhisperText = null;
        _activeJobId = Guid.NewGuid().ToString("N");
        _minimalStage = MinimalStage.Processing;
        _statusMessage = "Starting transcription...";

        try
        {
            var input = BuildAudioInput();
            if (input is null)
            {
                _errorMessage = "No audio available.";
                _minimalStage = MinimalStage.Capture;
                return;
            }

            var request = new BrowserTranscriptionRequest(
                _activeJobId,
                input.FileName,
                input.MimeType,
                input.Base64,
                _model,
                "auto",
                _enableSpeakerLabels,
                true, // Always use WebLLM
                _webLlmModel);

            var result = await JS.InvokeAsync<BrowserTranscriptionResult>(
                "localTranscriberBrowser.transcribeInBrowser",
                _dotNetRef,
                request);

            _rawWhisperText = result.RawWhisperText;
            _markdownOutput = result.Markdown;
            _statusMessage = "Complete!";
            _minimalStage = MinimalStage.Results;
        }
        catch (Exception ex)
        {
            _errorMessage = $"Transcription failed: {ex.Message}";
            _minimalStage = MinimalStage.Capture;
        }
        finally
        {
            _isSubmitting = false;
        }
    }

    [JSInvokable]
    public async Task OnBrowserProgress(BrowserProgressMessage message)
    {
        if (message.JobId != _activeJobId) return;

        _timeline.Insert(0, new ProgressItem(message.Percent, message.Message, message.IsCompleted, message.IsError));
        _statusMessage = message.Message;

        if (message.RawWhisperText is not null) _rawWhisperText = message.RawWhisperText;
        if (message.Markdown is not null) _markdownOutput = message.Markdown;

        await InvokeAsync(StateHasChanged);
    }

    private BrowserAudioInput? BuildAudioInput()
    {
        if (_browserRecording is not null)
            return new(_browserRecording.FileName, _browserRecording.MimeType, _browserRecording.Base64);
        if (_uploadedAudio is not null)
            return new(_uploadedAudio.FileName, _uploadedAudio.MimeType, Convert.ToBase64String(_uploadedAudio.Bytes));
        return null;
    }

    private Task ResetWorkflowAsync()
    {
        _minimalStage = MinimalStage.Capture;
        _timeline.Clear();
        _markdownOutput = null;
        _rawWhisperText = null;
        _errorMessage = null;
        _browserRecording = null;
        _uploadedAudio = null;
        return Task.CompletedTask;
    }

    private void BackToCapture() => _minimalStage = MinimalStage.Capture;
    private void SetResultTab(ResultTab tab) => _activeTab = tab;
    private string GetTabClass(ResultTab tab) => _activeTab == tab ? "tab-btn active" : "tab-btn";
    private string GetRecordClass() => _isRecording ? "recording" : "";
    private List<ProgressItem> GetLatestLogs(int count) => _timeline.Take(count).ToList();

    private async Task CopyToClipboardAsync()
    {
        var text = _activeTab == ResultTab.Raw ? _rawWhisperText : _markdownOutput;
        if (!string.IsNullOrEmpty(text))
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
    }

    private async Task ExportMarkdownAsync()
    {
        var text = _activeTab == ResultTab.Raw ? _rawWhisperText : _markdownOutput;
        if (string.IsNullOrEmpty(text)) return;

        var filename = $"transcription-{DateTime.Now:yyyyMMdd-HHmmss}.md";
        await JS.InvokeVoidAsync("eval", $@"
            const blob = new Blob([{System.Text.Json.JsonSerializer.Serialize(text)}], {{ type: 'text/markdown' }});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '{filename}';
            a.click();
            URL.revokeObjectURL(url);
        ");
    }

    private static string FormatBytes(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / (1024.0 * 1024.0):F1} MB";
    }

    public ValueTask DisposeAsync()
    {
        _dotNetRef?.Dispose();
        return ValueTask.CompletedTask;
    }

    private enum MinimalStage { Capture, Processing, Results }
    private enum ResultTab { Final, Raw, Logs }

    private record ProgressItem(int Percent, string Message, bool IsCompleted, bool IsError);
    private record AudioDevice(string DeviceId, string Label);
    private record MirrorInfo(string Url, string Name, string Region);
    private record PromptTemplatesJs(string? SystemMessage, string? CleanupPrompt, string? OutputTemplate);
    private record TuningOptionsJs(bool StrictTranscript, bool IncludeActionItems, int SummaryMinBullets, int SummaryMaxBullets, double Temperature, int Sensitivity);
    private record BrowserExecutionCapabilities(bool Supported, bool HasWebGpu, bool HasAudioContext, bool HasMediaRecorder, bool IsMobile, int EstimatedMemoryMB, string[]? RecommendedModels, string Reason);
    private record BrowserAudioPayload(string FileName, string MimeType, string Base64, long Size, string? PreviewUrl);
    private record UploadedAudioPayload(string FileName, string MimeType, byte[] Bytes);
    private record BrowserAudioInput(string FileName, string MimeType, string Base64);
    private record BrowserTranscriptionRequest(string JobId, string FileName, string MimeType, string Base64, string Model, string Language, bool EnableSpeakerLabels, bool UseWebLlm, string WebLlmModel);
    private record BrowserTranscriptionResult(string? RawWhisperText, string? SpeakerLabeledText, string? FormatterOutput, string? FormatterUsed, string? Markdown, int? DetectedSpeakerCount, object? SubtitleSegments);
    public record BrowserProgressMessage(string JobId, int Percent, string Stage, string Message, bool IsCompleted, bool IsError, string? RawWhisperText, string? SpeakerLabeledText, string? FormatterOutput, string? FormatterUsed, string? Markdown, int? DetectedSpeakerCount, object? SubtitleSegments);
}
